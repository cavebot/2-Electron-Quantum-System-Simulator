!---25/01/2019---
!Program calculates the 2-e Radial Distribution in terms of
!the 1-e radial wavefunctions, configuaration interaction coefficients,
!and TDSE coefficients according (Reference to be added)

program rd2e

    use parameter_tdse_fxd
    use bs_frb_2e,      only: read_target_energies
    use io
    use param,          only: np  !Number of wavefunction grid points
    use precision
    use atom_2e                 !Provides routines for reading CI coefficients

    implicit none

    real(DPK) :: dummie1, dummie2, dummie3, dummie4 ,dummie5
    integer   :: dummie6

    !Redundant variables now after reformulating loops. Fix this.
    integer                 :: counter !for checking progress
    integer                 :: i, ijmax       !Index for energies
    integer                 :: l, l1max                !Index for angular momenta
    integer                 :: ic, ic_p, ie, ie_p, ie_max         !Index for reformulated summations in terms of configuration number
    real(dpk), dimension(:,:), pointer :: en1e        !nl,ns

!Wavefunction variables
    integer                 :: ir, ir1, ir2         !Wavefunction point index, i.e piont 1, 2, etc
    real(DPK), dimension(np):: r                    !Wavfefunction grid values
    real(DPK),  dimension(:,:,:),   allocatable:: p    !Wavefunction values, P_nl(r)
    complex(DPK), dimension(:,:),   allocatable:: prr  !2e radial distribution
    complex(DPK), dimension(:,:),   allocatable:: work !dummy array for 2e distribution summation

    character(len=25) :: wf1efilename              !Wavefunction data file
    logical :: file_exists

!configuration interaction variables
    type(symmetry_ls2e), allocatable, dimension(:) :: w2e


!----------------------------Get number of states 1e from inp/h1e.inp -------------------------
    open(unit = 8, file = "inp/h1e.inp", status = 'old')

        !Dummie file read
        read(8, '(2f15.5,10x,a10)')           dummie1, dummie2
        read(8, '(a10,2f10.5,10x,a25)')       dummie3, dummie4, dummie5
        !read number of B-splines
        read(8, '(2I15,10x,a8)') ijmax, dummie6
        write(*,*) "#Number of b-splines = ", ijmax

    close(8)

        ijmax = ijmax - 2
        write(*,*) "#Number of eigenstates = ", ijmax
    write(*,*)
!------------------------Check wavefunction files exist. Retrive maximum angular momentum-----------

    l = 0
    write (wf1efilename, '(a,I1,a)') 'out/1ewavefunctions-',l,'.out'
    inquire(FILE = wf1efilename, EXIST = file_exists)

        if (file_exists) then
        write(*,*) "#Wavefunction files found"
        write(*,*) "#Finding number of partial wave files"
        write(*,*)
    else
        write(*,*) "#Could not find wavefunction files, 1ewavefunction-l.out."
        write(*,*) "#Terminating program"
        stop
    end if

    do while (file_exists)
        write (wf1efilename, '(a,I1,a)') 'out/1ewavefunctions-',l,'.out'
        inquire(FILE = wf1efilename, EXIST = file_exists)
        if(file_exists) then
            write(*,*) "#File found: ", wf1efilename
            l = l + 1
        else
            exit
        end if
    end do

    write(*,*)

    l1max = l
    write(*,*) "#Number of partial waves = l1max = ", l1max
    write(*,*) "#number of wavefunction points = ", np

!-------Read wavefunctions to p(np,ijmax,l1max). Tested 28/01/2019. Correct to this point--------

    allocate( p(np,ijmax,l1max) )
    loop_partial_waves: do l = 0, (l1max-1)

        write (wf1efilename, '(a,I1,a)') 'out/1ewavefunctions-',l,'.out'
            open(16, file = wf1efilename, status = 'old')

        loop_eigenstates: do i = 1, ijmax !i will be reused later, dummie variable for now

                loop_wavefunction_grid: do ir = 1, np

                    read(16,'(3E20.10)') r(ir), p(ir, i, l+1)

                end do loop_wavefunction_grid

        end do loop_eigenstates

        close(16)

    end do loop_partial_waves

    !--------------------------Read TDSE Coefficients and Configuration Interaction Coefficients-------------------------

    call input_tdse_fxd              ! tinp/tdse_bs_fxd_2e.inp
    call output_tdse_fxd             ! tout/tdse_bs_fxd_2e.out
    call read_target_energies(en1e)  ! read 1e energies (in Ryd)

    call read_w2e_ct(w2e,lmax)

    do l = 0, lmax
        call read_w2e_ci(w2e(l),l)     !reads coeffs Phi_j = \sum_i v_{ij} Phi^{(0)}_{i}
    end do

!-----------------------------------Apply summation equation-----------------------------------

    !Initialise 2e radial distribution matrix, prr = p(r1,r2)
    allocate( prr(np,np) )
    allocate( work(np,np) )
    prr(:,:) = 0.0_dpk
    work(:,:) = 0.0_dpk
    counter  = 0
!ijmax = 60
!lmax = 7
!Nmax = 5998 Need to import this from somewhere

write(*,*) "#Number of L=0 configurations in sum/prime sums = ", w2e(0)%ncf
write(*,*) "#Number of L=1 configurations in sum/prime sums = ", w2e(1)%ncf
write(*,*) "#Number of L=2 configurations in sum/prime sums = ", w2e(2)%ncf
write(*,*) "#Number of L=3 configurations in sum/prime sums = ", w2e(3)%ncf

loop_L: do l = 0, lmax

!Set maximum number of 2e energies to sum over for various L symmetries
if (l .eq. 0) then
    ie_max = 834 !Retrieves maximum number of 2e energies to sum over
else if (l .eq. 1) then
  ie_max = 1182 !Retrieves maximum number of 2e energies to sum over
else if (l .eq. 2) then
  ie_max = 1314 !Retrieves maximum number of 2e energies to sum over
else if (l .eq. 3) then
  ie_max = 1053 !Retrieves maximum number of 2e energies to sum over
end if
write(*,*) "#ie max = ", ie_max


loop_total_energy: do ie = 1, ie_max
!    loop_total_energy_prime: do ie_p = 1, ie_max

    loop_config_variables: do ic = 1, w2e(l)%ncf !sum from configuration 1 to max number of configurations, for the total angular symmetry l
    loop_primed_config_variables: do ic_p = 1, w2e(l)%ncf

        !make sure l1 and l2 variables are not selected incorrectly by using ic and ic_p
        if ( (w2e(l)%l1(ic) .eq. w2e(l)%l1(ic_p)) .and. (w2e(l)%l2(ic) .eq. w2e(l)%l2(ic_p))) then

                work(:,:) = 0.0_dpk
                loop_r1: do ir1 = 1, np
                    loop_r2: do ir2 = 1, np

                    !For equaivalent electrons
                    if (ir2 .ge. ir1) then

                        work(ir1,ir2) = (p(ir1,w2e(l)%n1(ic_p),w2e(l)%l1(ic)) * p(ir1,w2e(l)%n1(ic),w2e(l)%l1(ic)) * &
                        p(ir2,w2e(l)%n2(ic_p),w2e(l)%l2(ic)) * p(ir2,w2e(l)%n2(ic),w2e(l)%l2(ic))) + &
                        ((-1)**(w2e(l)%l1(ic)+w2e(l)%l2(ic)+l)) * &
                        (p(ir1,w2e(l)%n1(ic),w2e(l)%l1(ic)) * p(ir1,w2e(l)%n1(ic_p),w2e(l)%l2(ic)) * &
                        p(ir2,w2e(l)%n2(ic),w2e(l)%l2(ic)) * p(ir2,w2e(l)%n2(ic_p),w2e(l)%l1(ic)))

                        work(ir1,ir2) =  work(ir1,ir2)* (w2e(l)%cv(ie,ic)*w2e(l)%cv(ie,ic_p)* &
                        conjg(w2e(l)%ct(ie)) * w2e(l)%ct(ie))

                        prr(ir1,ir2) = prr(ir1,ir2) + work(ir1,ir2)

                    end if

                    end do loop_r2
                end do loop_r1

          end if

        end do loop_primed_config_variables


                                  !Test time taken
                                  counter = counter + 1
                                  write(*,*) counter
        end do loop_config_variables


    !end do loop_total_energy_prime
    end do loop_total_energy

end do loop_L

    !Save radial Distribution
    open(18, file = "out/RD2e.out", status = 'replace')


            do ir1 = 1, np
                do ir2 = 1, np

                  write(18,'(3E20.10)') prr(ir1,ir2), r(ir1), r(ir2)

                end do
            end do

    close(16)



end program rd2e
