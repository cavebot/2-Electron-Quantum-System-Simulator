module csNph_utils
  use precision,only:dpk
  use units, only:m_pi
  Use ang, only:c3j

  public
  
contains

!!! legendre polynomias generated by recursive relation
  subroutine plegendre(n,x,p)
    implicit none  
    integer i
    integer n          !legendre order
    real(dpk) x,p
    real(dpk), allocatable, dimension(:):: pleg
    

!      implicit doubleprecision (a-h,o-z)      
!      dimension pleg(0:10)

    allocate( pleg(0:n) ) 

!     Legendre polynomial

    pleg(0) = 1.0d+00
    pleg(1) = x
    
    do i = 2, n
       pleg(i) = ( (2*i-1)*x*pleg(i-1) - (i-1)*pleg(i-2) ) / i
    enddo

    p = pleg(n)
    
    deallocate(pleg)

    return
  end subroutine plegendre
!!!
!!! photoelectron angular distributions  (pad)
!!!
    SUBROUTINE pad(ien, wph, beta, nphotons,nout) 
      !
      IMPLICIT NONE 

      INTEGER              :: ien
      REAL(dpk)            :: wph
      REAL(dpk)            :: beta(0:nphotons)
      INTEGER              :: nphotons
      INTEGER              :: nout      
      !
      INTEGER              :: i,it
      CHARACTER(len=6)     :: si
      REAL(dpk)            :: pad_e, theta, x, theta_a, ds_a, ds_0, px      
      REAL(dpk)            :: p(0:nphotons)



    ds_0 = SUM(beta) 

    evaluate_dp_theta_k:IF(ien.NE.0) THEN 


       loop_over_angle_theta:DO it = 1, 180 
          
          theta = it  * m_pi/180.0_dpk       
          x = COS(theta)
         
          DO i = 0, nphotons             
             CALL plegendre(2*i,x,px)
             p(i) = px
          ENDDO
          

          p(0) = 1.0_dpk                                      !p0
          p(1) = (  3.0_dpk*x**2 - 1)/2.0_dpk                 !p2
          p(2) = ( 35.0_dpk*x**4 - 30.0_dpk * x**2 + 3)/8     !p4
!          p(3) = ( 231.0_dpk * x**6 - 315.0_dpk * x**4 + 105_dpk * x**2 - 5.0_dpk )/16.0_dpk
!          p(4) = ( 231.0_dpk * x**6 - 315.0_dpk * x**4 + 105_dpk * x**2 - 5.0_dpk )/16.0_dpk

!          values for 4-photon (532nm) in Mg (diMauro exp)
!          beta(0) = 0.904
!          beta(1) = 1.0
!          beta(2) = 1.129
!          beta(3) = -0.266
!          beta(4) = 0.517
          

          pad_e = DOT_PRODUCT(beta,p) 
 

          IF(it.EQ.90)   THEN
             ds_a  = pad_e
          ENDIF
          WRITE(nout,*) theta*(180.0_dpk/m_pi), pad_e

       ENDDO loop_over_angle_theta



       WRITE(*,*) "# pad::                nphotons = ", nphotons
       WRITE(*,*) "# pad::           energy index  = ", ien
       WRITE(*,*) "# pad::           photon energy = ", wph
       WRITE(*,*) "# pad::      ratio ds(0)/ds(90) = ", ds_0/ds_a

       DO i = 0, nphotons 

          WRITE(si,'(i6)') 2*i
          WRITE(*,*) "# pad::                    b("//TRIM(ADJUSTL(si))//") = ", beta(i)
          !WRITE(*,*) "# pad::                    b("//TRIM(ADJUSTL(si))//") = ", beta(i)/beta(1)
       ENDDO

             
    ELSE IF(ien.EQ.0) THEN 
            
       
       theta_a = m_pi/2.0_dpk   !90^o degrees

       x = COS(theta_a)
       do i = 0, nphotons          
          call plegendre(2*i,x,px)
          p(i) = px
       enddo

!       p(0) = 1.0_dpk 
!       p(1) = ( 3.0_dpk*x**2 - 1)/2.0_dpk
!       p(2) = ( 35.0_dpk*x**4 - 30.0_dpk * x**2 + 3.0_dpk)/8.0_dpk
       
       ds_a = dot_product(beta,p) 

       WRITE(nout,*) wph, ds_0/ds_a 

    ENDIF evaluate_dp_theta_k

!...............................................................

  END SUBROUTINE pad
  

  REAL(dpk) FUNCTION beta_k(kp, m_n_2, l, dmx_l, delta_l, nl) RESULT (bpp)
    IMPLICIT NONE 
    INTEGER i,j
    INTEGER kp,nl
    INTEGER l(nl)
    REAL(dpk) dmx_l(nl), delta_l(nl)
    REAL(dpk) m_n_2,dl,dl21
    INTEGER  l1
    INTRINSIC sqrt

!...........................


    bpp = 0.0_dpk
    DO i = 1, nl
       bpp =  bpp + (2*l(i) + 1) * c3j( 2*kp, 0, 2*l(i),0, 2*l(i), 0 )**2 * dmx_l(i)**2 
    ENDDO
    
!

!!! interference part  (single channel from ns^2 -> ns + e-(el) )

    DO i = 1, nl  
       DO j = i+1, nl 

          IF(i.EQ.2) delta_l(i) = 0
          IF(j.EQ.2) delta_l(j) = 0
          
!          if(i.eq.4) delta_l(i) = 0
!          if(j.eq.4) delta_l(j) = 0

          dl =  delta_l(i) - delta_l(j) 


          bpp = bpp + SQRT( DBLE(2*l(i) + 1) ) * SQRT( DBLE(2*l(j) + 1) )   &
                 &          * c3j( 2*kp, 0, 2*l(i),0, 2*l(j), 0 )**2        &
                 &          * 2.0d+00 * dmx_l(i) * dmx_l(j) * COS(dl) 
       ENDDO
    ENDDO
    

    bpp  =   (2*kp+1) * bpp/m_n_2     

    
! hand expressions for pad_n  
! (only the terms with interference between the partial waves are 
!  added to the main expression)
!!!............................ 2-photon  
!!! b2 


!    dl =  delta_l(1)  - delta_l(2) 
!    if(kp.eq.2) then!
!       bpp = bpp + 2*dmx_l(1)*dmx_l(2)*cos(dl)/sqrt(dble(2*kp+1))
!    endif
! 
!     bpp  =   (2*kp+1) * bpp/m_n_2     

!!!........................... 3-photon  
!!! b2
!        dl = delta_l(1) - delta_l(2) 
!    if(kp.eq.2) then
!       bpp = bpp + 6.0d+00 * sqrt(3.0/7.0)* dmx_l(1)*dmx_l(2)*cos(dl)/dble(2*kp+1)
!    endif
!!! b4
!    if(kp.eq.4) then
!       bpp = bpp + 8.0d+00 *sqrt(3.0/7.0)* dmx_l(1)*dmx_l(2)*cos(dl)/dble(2*kp+1)
!    endif
!     bpp  =   (2*kp+1) * bpp/m_n_2     

!!!..............  4- photon 
!!$    if(kp.eq.2) then
!!$       bpp = ((10.0d+00/7.0d+00) * dmx_l(2)**2  + (100.0d+00/77.0d+00) * dmx_l(3)**2)/dble(2*kp+1) 
!!$    endif
!!$   if(kp.eq.4) then
!!$       bpp = ((18.0d+00/7.0d+00) * dmx_l(2)**2  + (1458.0d+00/1001.0d+00) * dmx_l(3)**2)/dble(2*kp+1)  
!!$    endif
!!$    if(kp.eq.6) then
!!$       bpp = (20.0d+00/11.0d+00) * dmx_l(3)**2/dble(2*kp+1)   
!!$    endif
!!$    if(kp.eq.8) then
!!$       bpp = (490.0d+00/143.0d+00) * dmx_l(3)**2/dble(2*kp+1)   
!!$    endif

!!$ inteference part

!!$    dl21 = delta_l(2) - delta_l(1) 
!!$    dl23 = delta_l(2) - delta_l(3) 
!!$    dl13 = delta_l(1) - delta_l(3) 
!!$
!!$    if(kp.eq.2) then
!!$       bpp = bpp + (4.0d+00/7.0d+00) * sqrt(45.0d+00)* dmx_l(2)*dmx_l(3)*cos(dl23)/dble(2*kp+1) &
!!$   &             +            2.0d+00 * sqrt(5.0d+00)* dmx_l(2)*dmx_l(1)*cos(dl21)/dble(2*kp+1) 
!!$    endif
!!$    if(kp.eq.4) then
!!$       bpp = bpp &
!!$   &         + (40.0d+00/77.0d+00) * sqrt(45.0d+00)* dmx_l(2)*dmx_l(3)*cos(dl23)/dble(2*kp+1) &
!!$   &         +       6.0d+00 * dmx_l(3)*dmx_l(1)*cos(dl13)/dble(2*kp+1) 
!!$    endif
!!$    if(kp.eq.6) then
!!$    bpp = bpp + (10.0d+00/11.0d+00) * sqrt(45.0d+00)* dmx_l(2)*dmx_l(3)*cos(dl23)/dble(2*kp+1) 
!!$!       write(*,*) kp,dl23,cos(dl23)
!!$    endif
!     bpp  =   (2*kp+1) * bpp/m_n_2     

  END FUNCTION beta_k


!
!31082004LAANJYOTO:
!
! this subroutines make a simple linear interpolation.
! The input/output values are given in the form of 
! assumed 1-d arrays.
! the values to be interpolated y = f( x(1:nx) )
! and the interpolation points are the xn(1:nxn)
! 
! The input array values (xn) have to be sorted in 
! increasing order.
!
! when    xn(i) < minval(x) and xn(i) > maxval(x) 
!         yn(i) = 0. 
!
 SUBROUTINE LINEAR_INTERPOLATION(x,y,nx,xn,yn,nxn,check)
    
    IMPLICIT NONE

!.....................
  integer i,j, nx, nxn
  integer a,b
  integer ia(1)
  integer nio
  real(dpk)  dx, dy, alpha, bt
!!! input values
  real(dpk)   x(nx),y(nx)
  real(dpk)  xn(nxn),yn(nxn)    ! output value
  integer check
!!! inner use
  real(dpk)  dxn(nx)

!.................


  nio = 16


!!!.. flash out the input data
 
  open(nio,file='out/xy.out') 
  do i = 1, nx
     write(nio,*) x(i), y(i) 
  enddo  
  close(nio)


!.. interpolate at the input sample points 

  write(*,*) "# linterp:                 :         check =  ",check

  if(check.eq.1) then
     write(*,*) "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"   
     write(*,*) "# linterp:                 :          x_min = ",minval(x)
     write(*,*) "# linterp::                           x_max = ",maxval(x)
  endif


  do j = 1, size(xn)


     if((xn(j) > minval(x)).and.(xn(j) < maxval(x))) then 
        
        
        dxn = xn(j) - x(1:nx)

        ia = minloc(abs(dxn))
        
        a = ia(1) 

        if( xn(j) < x(a) )          a = a - 1

        b = a + 1

      !                 check for incosistencies at the data
         
        if( a == b ) then 

           write(*,*) "# linterp:: error a anb b are equal. "
           write(*,*) "# linterp::                      a = ", a
           write(*,*) "# linterp::                      b = ", b
           stop
        else if( (b-a).ne.1 ) then 

           write(*,*) "# linterp:: error b-a not equal to 1."
           write(*,*) "# linterp::                      a = ", a
           write(*,*) "# linterp::                      b = ", b
           stop
        else
                   
           dx = x(b) - x(a)
           dy = y(b) - y(a) 
           
           alpha =  dy / dx 
        
           bt  = ( y(a)* x(b) - y(b) * x(a) ) / dx
       
           yn(j)  = alpha * xn(j) + bt   

       if(check.eq.1) then 
          write(*,*) "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"   
          write(*,*) "# linterp::              a, xa = ",a, x(a)
          write(*,*) "# linterp::              j, xj = ",j, xn(j)
          write(*,*) "# linterp::              b, xb = ",b, x(b)
          write(*,*) "# linterp::                 ya = ",y(a)
          write(*,*) "# linterp::                 yn = ",yn(j)
          write(*,*) "# linterp::                 yb = ",y(b)
          write(*,*) "# linterp::              alpha = ",alpha
          write(*,*) "# linterp::                 bt = ",bt
       endif

        endif


     else

        yn(j) = 0.0d+00

     endif


     
  enddo

  
  open(nio,file='out/xyn.out')
  do i = 1, size(xn)
        write(nio,*) xn(i), yn(i)
  enddo

  close(nio)
   

END SUBROUTINE LINEAR_INTERPOLATION

end module csNph_utils
!###########################################################
    !#eof
